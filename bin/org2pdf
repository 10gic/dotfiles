#!/bin/bash

# Convert org file into pdf
# Dependencies:
# 1. Emacs
# 2. xelatex
# 3. inkscape (if org file include svg file)
# 4. exiftool (if org file include gif file)
# 5. ImageMagick (if org file include gif file)

log_level=3

YELLOW='\033[01;33m'  # bold yellow
RED='\033[01;31m'     # bold red
RESET='\033[00;00m'   # normal white

log_err() {
    if [[ $log_level -ge 1 ]]; then
        printf "[${RED}error${RESET}] $@\n" >&2
    fi
}

log_warn() {
    if [[ $log_level -ge 2 ]]; then
        printf "[${YELLOW}warn${RESET}] $@\n" >&2
    fi
}

log_info() {
    if [[ $log_level -ge 3 ]]; then
        printf "[info] $@\n" >&2
    fi
}

main() {
    if [ ${#@} -ne 1 ] && [ ${#@} -ne 2 ] && [ ${#@} -ne 3 ]; then
        echo 'This tool converts orgmode file to pdf.' >&2;
        echo 'Usage: org2pdf [-k] input.org [output_dir]' >&2;
        echo '' >&2;
        echo '-k, keep intermediate files' >&2;
        exit 1
    fi

    local removelogfiles=t     # nil or t (default)
    if [ "$1" = "-k" ]; then
        removelogfiles=nil
        shift
    fi

    local orgfile="$1"
    if [ ! -e ${orgfile} ]; then
        log_err "File ${orgfile} does not exist, do nothing."
        exit 1;
    fi

    local outputdir="$2"
    if [ -n "${outputdir}" ] && [ ! -d "${outputdir}" ]; then
        log_err "Directory ${outputdir} does not exist, do nothing."
        exit 1;
    fi

    ## Add width for images, eg. #+ATTR_LATEX: :width 300px
    if fgrep -q '#+ATTR_HTML:' "${orgfile}"; then
        patch_with_latex_width "${orgfile}" "${orgfile/%org/addwidth.org}"
        orgfile="${orgfile/%org/addwidth.org}"
    fi

    ## There are issues when export latex file with svg image.
    if fgrep -q '.svg]]' "${orgfile}"; then
        workaround_for_svg "${orgfile}" "${orgfile/%org/nosvg.org}"
        orgfile="${orgfile/%org/nosvg.org}"
    fi

    ## There are issues when export latex file with gif image.
    if fgrep -q '.gif]]' "${orgfile}"; then
        workaround_for_gif "${orgfile}" "${orgfile/%org/nogif.org}"
        orgfile="${orgfile/%org/nogif.org}"
    fi

    local EMACS=emacs
    if [[ "$(uname -s)" == "Darwin" ]] && [[ -x /Applications/Emacs.app/Contents/MacOS/Emacs ]]; then
        EMACS=/Applications/Emacs.app/Contents/MacOS/Emacs
    fi

    log_info "Begin generating pdf for $1."
    if [ -e ~/.emacs.d/customize-org.el ]; then
        $EMACS -batch -l "~/.emacs.d/customize-org.el" -f toggle-debug-on-error -eval \
               "(progn
                    (setq org-export-allow-bind-keywords t
                          org-confirm-babel-evaluate nil
                          org-latex-remove-logfiles ${removelogfiles})
                    (find-file \"${orgfile}\") (org-latex-export-to-pdf))" 2>>emacs.log
    else
        $EMACS -batch -f toggle-debug-on-error -eval \
               "(progn
                    (setq org-export-allow-bind-keywords t
                          org-confirm-babel-evaluate nil
                          org-latex-remove-logfiles ${removelogfiles})
                    (setq org-latex-pdf-process
                          '(\"xelatex -interaction nonstopmode -output-directory %o %f\"
                            \"xelatex -interaction nonstopmode -output-directory %o %f\"
                            \"xelatex -interaction nonstopmode -output-directory %o %f\"))
                    (find-file \"${orgfile}\") (org-latex-export-to-pdf))" 2>>emacs.log
    fi

    local pdf="${orgfile/%org/pdf}"
    if [ -s "${pdf}" ]; then
        local target="${1/%org/pdf}"
        mv "${pdf}" "${target}"
        if [ -n "${outputdir}" ]; then
            mv "${target}" "${outputdir}"
        fi
        log_info "Generate pdf for $1 finished."
        exit 0;
    else
        log_err "Fail to generate pdf for $1, see log ${PWD}/emacs.log"
        exit 1;
    fi
}

patch_with_latex_width() {
    local in_file=$1
    local out_file=$2
    awk -v fn="$in_file" '
{
    print $0;
    if ($0 ~ /^#\+ATTR_HTML:.*:width/) {      # example of $0:  #+ATTR_HTML: :width 300px
        width="";
        for(i = 1; i <= NF; i++) {
            if ($i == ":width") {
                width=$(i+1)
                break;
            }
        }

        checklines=2;         # only check next 2 lines
        needpatch=1;
        nextlines="";         # backup lines read by getline
        while ((getline line) > 0) {
            checklines--;
            if (nextlines == "") {
                nextlines = line;
            } else {
                nextlines = nextlines"\n"line;
            }

            if (toupper(line) == "#+END_EXAMPLE") {
                ## find "#+END_EXAMPLE" in following line, do nothing.
                print "Skip converting width in line "FNR" ["$0"] in file "fn  > "/dev/stderr"
                needpatch=0;
                break;
            }
            if (match(toupper(line), /^#\+ATTR_LATEX:.*:WIDTH .*/)) {
                ## already has "#+ATTR_LATEX: :width", do nothing.
                print "Already has ATTR_LATEX width after line "FNR" ["$0"] in file "fn", skip it"  > "/dev/stderr"
                needpatch=0;
                break;
            }
            if (checklines == 0) { break; }
        }

        if (width == "") {
            print "Cannot find value of width in line ["$0"] in file "fn  > "/dev/stderr"
        } else if (match(width, /^[0-9]+px$/)) {
            # Only support 100px, 230px, etc.
            if (needpatch == 1) {
                # do following converting.
                # 100px  (ATTR_HTML)  ------>   60pt (ATTR_LATEX)
                # 200px  (ATTR_HTML)  ------>   120pt (ATTR_LATEX)
                width=substr(width, 1, length(width) - 2)    # remove suffix "px"
                width=0.6*width
                print "#+ATTR_LATEX: :width "width"pt";
            }
        } else {
            if (needpatch == 1) {
                print "Does not support convert width in line ["$0"] to counterpart"  > "/dev/stderr"
            }
        }
        print nextlines;
    }
}' "$in_file" >"$out_file"
}

## Find all [[xxxxx.svg]] (svg can customized by $2) in file, but filter out it if it just before #+END_EXAMPLE
##
## [[./images/example1.svg]]        #### would print ./images/example1.svg
## [[./images/example2.svg]]        #### would print ./images/example2.svg
## ......
## #+BEGIN_EXAMPLE
## [[./images/example3.svg]]        <=== would NOT print this images as it just before #+END_EXAMPLE
## #+END_EXAMPLE
get_images() {
    local file=$1
    local image_suffix=$2       # image_suffix example: svg, gif
    awk -v fn=${file} -v pattern=${image_suffix} '$0 ~ "^\\[\\[.*\\."pattern"\\]\\]$" {   # eg. [[xxxxxx.svg]]
    checklines=2;       # only check next 2 lines
    find_end_example=0;
    while (((getline line) > 0) && (checklines > 0)) {
        checklines--;
        if (toupper(line) == "#+END_EXAMPLE") {
            find_end_example=1;
            break;
        }
    }
    if (find_end_example == 1) {
        print "Find "$0" in file "fn" is just before #+END_EXAMPLE, skip this image" > "/dev/stderr"
    } else {
        print substr($0, 3, length($0) - 4)  # remove first and last two characters, i.e. [[xxxxxx.svg]]  ---> xxxxxx.svg
    }
}' "${file}"
}

## If svg image exist in file, change [[./xxx/image.svg]] to [[./xxx/image.pdf]]
## Note: Please make sure there is corresponding pdf image,
## If not, PLEASE convert svg to pdf (for example: `inkscape -f file.svg -A file.pdf;`)
workaround_for_svg() {
    local in_file=$1
    local out_file=$2
    local temp_file=$(mktemp /tmp/org2pdf.XXXXXX)
    cp "$in_file" "$temp_file"
    for svg_file in $(get_images "${in_file}" "svg");
    do
        local dir=$(dirname "${in_file}")
        local svg_path=${dir}/${svg_file}
        local pdf_file=${svg_path/%svg/pdf}
        if [ ! -s ${pdf_file} ]; then
            # convert svg to pdf if pdf does not exsit
            log_info "Convert svg file ${svg_path} to pdf."
            cd $(dirname "${svg_path}")     # inkscape may fail if we don't enter dir
            inkscape --without-gui -f "$PWD"/$(basename "$svg_file") -A "$PWD"/$(basename "${pdf_file}")
            cd -
            if [[ ! -s ${pdf_file} ]]; then
                log_err "Convert svg ${svg_path} to ${pdf_file} failed, skip this svg."
                continue;
            fi
        fi

        ## change [[./xxx/image.svg]] to [[./xxx/image.pdf]]
        sed -i.bak "s@^\[\[${svg_file}\]\]@[[${svg_file/%svg/pdf}]]@" "$temp_file"
    done
    cp "$temp_file" "$out_file"
    # log_info $temp_file
    rm -rf "$temp_file"
}

## If gif image exist in file, change [[./xxx/image.gif]] to [[./xxx/image.pdf]]
## Note: Please make sure there is corresponding pdf image,
## If not, you can convert gif to pdf by `sips -s format pdf file.gif --out file.pdf;` in Mac
workaround_for_gif() {
    local in_file=$1
    local out_file=$2
    local temp_file=$(mktemp /tmp/org2pdf.XXXXXX)
    cp "$in_file" "$temp_file"
    for gif_file in $(get_images "${in_file}" "gif");
    do
        local dir=$(dirname "${in_file}")
        local gifpath=${dir}/${gif_file}
        local gifbasenm=$(basename ${gifpath})
        if [[ ! -a $gifpath ]]; then
            log_warn "Gif file ${gifpath} does not exist, skip this gif."
            continue;
        fi

        local frameNum;
        frameNum=$(exiftool -FrameCount ${gifpath});
        ## An example of exiftool output:
        ## Frame Count                     : 212
        if [[ $? -ne 0 ]]; then
            log_err "Get frame count of gif ${gifpath} failed, skip this gif."
            continue;
        fi
        frameNum=$(echo $frameNum | awk -F': ' '{print $2}')  # only get number (for example 212)
        if [[ "$frameNum" -gt 1 ]]; then
            # If the gif is an animated gif

            # log_info "Gif file ${gifpath} contains ${frameNum} frames."

            # convert file.gif to multiple files: file_frames/frame-0.png, file_frames/frame-1.png, etc.
            local gif_expend_dir="${gifpath%.gif}_frames"
            mkdir -p "${gif_expend_dir}"
            convert -coalesce ${gifpath} "${gif_expend_dir}/frame.png"
            if [[ $? -ne 0 ]]; then
                log_err "Convert gif ${gifpath} to multiple png failed, skip this gif."
                continue;
            fi
            local dura=$(exiftool -Duration ${gifpath} | awk -F': ' '{print $2}' | awk '{print $1}')
            # An example of `exiftool -Duration file.gif`:
            # Duration                        : 16.96 s
            local frameRate=$(echo "scale=2; ${frameNum}/${dura}" |bc) # specifies the number of frames per second of the animation
            local lastNum=$((${frameNum}-1))           # first number is 0, so last number is frameNum -1
            local label=$(grep -B 10 "\[\[${gif_file}\]\]" "${in_file}" | awk '{if ($1=="#+NAME:") print $2}' | tail -n 1)
            if [[ -z $label ]]; then
                log_warn "Can't get label for image $gif_file"
                label="NOLABLE"
            fi
            local caption=$(grep -B 10 "\[\[${gif_file}\]\]" "${in_file}" | awk '{if ($1=="#+CAPTION:") print $2}' | tail -n 1)
            if [[ -z $caption ]]; then
                log_warn "Can't get caption for image $gif_file"
                caption="NOCAPTION"
            fi
            local width=$(grep -B 10 "\[\[${gif_file}\]\]" "${in_file}" | awk '{if ($1=="#+ATTR_LATEX:" && $2==":width") print $3}' | tail -n 1)
            local widthStr=""
            if [[ -z $width ]]; then
                : # log_warn "Can't get width for image $gif_file"
            else
                widthStr=",width=${width}"
            fi
            sed -i.bak "s@^\[\[${gif_file}\]\]@\\\\begin{figure}\[!htbp\]\\
\\\\centering\\
  \\\\animategraphics\[controls ${widthStr}\]{${frameRate}}{${gif_file%.gif}_frames/frame-}{0}{${lastNum}}\\
\\\\caption{\\\\label{${label}} ${caption}}\\
\\\\end{figure}\\
@" "$temp_file"
            # #+ATTR_LATEX: :width 500pt
            # #+NAME: fig:test_3
            # #+CAPTION: $ab=c$ test
            # [[./images/test.gif]
            # ---------->
            # \begin{figure}[!htbp]
            # \centering
            #   \animategraphics[controls, width=500pt]{2}{test_frames/}{1}{3}
            # \caption{\label{fig:test_3} $ab=c$ test}
            # \end{figure}
            #
            # NOTE: need \usepackage{animate}
        else
            # If the gif only contains one frame (not an animated gif).

            # log_info "Gif file ${gifpath} contains only one frame, change gif to pdf."
            local pdf_file=${gifpath/%gif/pdf}
            if [ ! -s ${pdf_file} ]; then
                log_info "Convert gif file ${gifpath} to pdf."
                # convert gif to pdf if pdf does not exsit
                sips -s format pdf ${gifpath} --out ${pdf_file}
                if [[ ! -s ${pdf_file} ]]; then
                    log_err "Convert gif ${gifpath} to ${pdf_file} failed, skip this gif."
                    continue;
                fi
            fi

            ## change [[./xxx/image.gif]] to [[./xxx/image.pdf]]
            sed -i.bak "s@^\[\[${gif_file}\]\]@[[${gif_file/%gif/pdf}]]@" "$temp_file"
        fi
    done
    cp "$temp_file" "$out_file"
    # log_info $temp_file
    rm -rf "$temp_file"
}

main "$@"
